<!DOCTYPE html>
	<html>
		<head>
			<meta charset="UTF-8">
			<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
			<meta http-equiv="Pragma" content="no-cache">
			<meta http-equiv="Expires" content="0">
			<title>{{ page.title }}</title>
			<!-- link to main stylesheet -->
			<link rel="stylesheet" type="text/css" href="/css/main.css">
			<link rel="preconnect" href="https://fonts.googleapis.com">
			<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
			<link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&display=swap" rel="stylesheet">
		</head>
		<body>
		<!-- Mobile hamburger menu -->
		<button class="hamburger-toggle" id="hamburger-toggle" onclick="toggleHamburgerMenu()" aria-label="Open menu and timeline">
			<span></span>
			<span></span>
			<span></span>
		</button>			<!-- Mobile menu overlay -->
			<div class="mobile-menu-overlay" id="mobile-menu-overlay" onclick="closeHamburgerMenu()"></div>
			
			<!-- Mobile menu sidebar -->
			<div class="mobile-menu" id="mobile-menu">
				<div class="mobile-menu-header">
					<h3>Menu & Timeline</h3>
					<button class="mobile-menu-close" onclick="closeHamburgerMenu()">âœ•</button>
				</div>
				
				<!-- Navigation Links -->
				<div class="mobile-menu-section">
					<h4>Navigation</h4>
					<ul class="mobile-nav-links">
						<li><a href="{{ '/' | relative_url }}" onclick="closeHamburgerMenu()">Home</a></li>
						<li><a href="{{ '/about' | relative_url }}" onclick="closeHamburgerMenu()">About</a></li>
						<li><a href="{{ '/cv' | relative_url }}" onclick="closeHamburgerMenu()">CV</a></li>
						<!-- <li><a href="{{ '/blog' | relative_url }}" onclick="closeHamburgerMenu()">Blog</a></li> -->
					</ul>
				</div>
				
				<!-- Timeline Section (only shown on about page) -->
				<div class="mobile-menu-section timeline-section" id="mobile-timeline-section" style="display: none;">
					<h4>Timeline Navigation</h4>
					<p class="timeline-hint">Jump to different periods:</p>
					<div class="mobile-timeline-container" id="mobile-timeline-container">
						<!-- Timeline items will be populated by JavaScript on about page -->
					</div>
				</div>
				
				<!-- Theme Toggle -->
				<div class="mobile-menu-section">
					<button class="mobile-theme-toggle" onclick="toggleTheme()">
						<span id="mobile-theme-text">Dark Mode</span>
					</button>
				</div>
			</div>
			
			<nav>
	    		<ul>
	        		<li><a href="{{ '/' | relative_url }}">Home</a></li>
		        	<li><a href="{{ '/about' | relative_url }}">About</a></li>
	        		<li><a href="{{ '/cv' | relative_url }}">CV</a></li>
	        		<!-- <li><a href="{{ '/blog' | relative_url }}">Blog</a></li> -->
	    		</ul>
			</nav>
			<button id="theme-toggle" aria-label="Toggle dark mode">Dark</button>
			<div class="container">
			
			{{ content }}
			
			</div><!-- /.container -->
			<footer>
	    		<ul>
	        		<li><a href="google.com">email: lepakshiramkiran <-(o)-> hotmail.com</a></li>
	        		<li><a href="https://github.com/iamlrk">github.com/iamlrk</a></li>
				</ul>
			</footer>
			<script>
				// Hamburger menu functionality
				function toggleHamburgerMenu() {
					const menu = document.getElementById('mobile-menu');
					const overlay = document.getElementById('mobile-menu-overlay');
					const toggle = document.getElementById('hamburger-toggle');
					
					if (menu.classList.contains('active')) {
						closeHamburgerMenu();
					} else {
						openHamburgerMenu();
					}
				}
				
				function openHamburgerMenu() {
					const menu = document.getElementById('mobile-menu');
					const overlay = document.getElementById('mobile-menu-overlay');
					const toggle = document.getElementById('hamburger-toggle');
					
					menu.classList.add('active');
					overlay.classList.add('active');
					toggle.classList.add('active');
					document.body.style.overflow = 'hidden';
					
					// Populate timeline if on about page
					populateTimelineInMenu();
				}
				
				function closeHamburgerMenu() {
					const menu = document.getElementById('mobile-menu');
					const overlay = document.getElementById('mobile-menu-overlay');
					const toggle = document.getElementById('hamburger-toggle');
					
					menu.classList.remove('active');
					overlay.classList.remove('active');
					toggle.classList.remove('active');
					document.body.style.overflow = '';
				}
				
				function populateTimelineInMenu() {
					const timelineSection = document.getElementById('mobile-timeline-section');
					const timelineContainer = document.getElementById('mobile-timeline-container');
					
					// Check if we're on the about page and timeline items exist
					const timelineItems = document.querySelectorAll('.timeline-item');
					if (timelineItems.length > 0 && window.location.pathname.includes('about')) {
						timelineSection.style.display = 'block';
						timelineContainer.innerHTML = '';
						
						timelineItems.forEach(item => {
							const period = item.getAttribute('data-period');
							const dateText = item.querySelector('.timeline-date').textContent;
							
							const menuItem = document.createElement('div');
							menuItem.className = 'mobile-timeline-item';
							menuItem.innerHTML = `<span>${dateText}</span>`;
							menuItem.onclick = () => {
								if (window.showTimelineContent) {
									window.showTimelineContent(period);
								}
								closeHamburgerMenu();
							};
							
							// Add active class if timeline item is active
							if (item.classList.contains('active')) {
								menuItem.classList.add('active');
							}
							
							timelineContainer.appendChild(menuItem);
						});
					} else {
						timelineSection.style.display = 'none';
					}
				}
				
				function toggleTheme() {
					const themeToggle = document.getElementById('theme-toggle');
					if (themeToggle) {
						themeToggle.click();
					}
					// Update mobile theme toggle text
					updateMobileThemeToggle();
				}
				
			function updateMobileThemeToggle() {
				const mobileThemeText = document.getElementById('mobile-theme-text');
				const currentTheme = document.body.getAttribute('data-theme');
				if (mobileThemeText) {
					const mobileThemeNames = {
						'light': 'Dark Mode',
						'dark': 'Light Mode'
					};
					mobileThemeText.textContent = mobileThemeNames[currentTheme] || 'Dark Mode';
				}
			}
				
				// Keyboard support
				document.addEventListener('keydown', function(e) {
					if (e.key === 'Escape') {
						closeHamburgerMenu();
					}
				});
				
				// Initialize mobile theme toggle text
				document.addEventListener('DOMContentLoaded', function() {
					updateMobileThemeToggle();
				});
			</script>
			
			<script>
		// Theme switching functionality - Light and Dark Brutalism
		const themeToggle = document.getElementById('theme-toggle');
		const body = document.body;
		const themes = ['light', 'dark'];
			
			// Check for saved theme or default to light mode
			const currentTheme = localStorage.getItem('theme') || 'light';
			body.setAttribute('data-theme', currentTheme);
			updateToggleButton(currentTheme);
			
			themeToggle.addEventListener('click', () => {
				const currentTheme = body.getAttribute('data-theme');
				const currentIndex = themes.indexOf(currentTheme);
				const nextIndex = (currentIndex + 1) % themes.length;
				const newTheme = themes[nextIndex];
				
				body.setAttribute('data-theme', newTheme);
				localStorage.setItem('theme', newTheme);
				updateToggleButton(newTheme);
			});
			
			function updateToggleButton(theme) {
				const themeNames = {
					'light': 'Dark',
					'dark': 'Light'
				};
				themeToggle.textContent = themeNames[theme] || 'Dark';
				updateMobileThemeToggle();
			}
			</script>
			
			<script>
				// Skills Carousel Functionality - Infinite Scroll
				document.addEventListener('DOMContentLoaded', function() {
					const track = document.getElementById('skills-track');
					const prevBtn = document.getElementById('skills-prev');
					const nextBtn = document.getElementById('skills-next');
					const dotsContainer = document.getElementById('skills-dots');
					
					if (!track || !prevBtn || !nextBtn || !dotsContainer) return;
					
					// Store original cards and create infinite scroll setup
					const originalCards = Array.from(track.children);
					const totalCards = originalCards.length;
					let cardWidth = 200;
					let gap = 20;
					let currentIndex = 0;
					let actualIndex = 0; // For tracking real position in original array
					let isTransitioning = false;
					let autoPlayInterval = null;
					
					// Clone cards for infinite effect
					function setupInfiniteScroll() {
						// Clear track
						track.innerHTML = '';
						
						// Clone last few cards at the beginning
						const clonesAtStart = Math.min(3, totalCards);
						for (let i = totalCards - clonesAtStart; i < totalCards; i++) {
							const clone = originalCards[i].cloneNode(true);
							clone.classList.add('carousel-clone');
							track.appendChild(clone);
						}
						
						// Add original cards
						originalCards.forEach(card => {
							track.appendChild(card.cloneNode(true));
						});
						
						// Clone first few cards at the end
						const clonesAtEnd = Math.min(3, totalCards);
						for (let i = 0; i < clonesAtEnd; i++) {
							const clone = originalCards[i].cloneNode(true);
							clone.classList.add('carousel-clone');
							track.appendChild(clone);
						}
						
						// Set initial position to first real card (after clones)
						currentIndex = clonesAtStart;
						actualIndex = 0;
					}
					
					function calculateDimensions() {
						const carouselWidth = track.parentElement.offsetWidth;
						const currentTheme = document.body.getAttribute('data-theme');
						
						cardWidth = 200;
						gap = 20;
						
						return {
							visibleCards: Math.floor(carouselWidth / (cardWidth + gap)),
							maxIndex: Math.max(0, totalCards - Math.floor(carouselWidth / (cardWidth + gap)))
						};
					}
					
					function createDots() {
						dotsContainer.innerHTML = '';
						const { maxIndex } = calculateDimensions();
						
						for (let i = 0; i <= maxIndex; i++) {
							const dot = document.createElement('div');
							dot.className = 'carousel-dot';
							if (i === actualIndex) dot.classList.add('active');
							dot.addEventListener('click', () => goToSlide(i));
							dotsContainer.appendChild(dot);
						}
					}
					
					function updateCarousel(withTransition = true) {
						if (withTransition) {
							track.style.transition = 'transform 0.5s ease';
						} else {
							track.style.transition = 'none';
						}
						
						// Calculate offset to account for the clones at the start
						const clonesAtStart = Math.min(3, totalCards);
						const offsetIndex = currentIndex - clonesAtStart;
						const translateX = -offsetIndex * (cardWidth + gap);
						track.style.transform = `translateX(${translateX}px)`;
						
						// Enable looping - never disable buttons
						prevBtn.disabled = false;
						nextBtn.disabled = false;
						
						// Update actualIndex based on current position
						if (currentIndex >= clonesAtStart && currentIndex < clonesAtStart + totalCards) {
							actualIndex = currentIndex - clonesAtStart;
						}
						
						const dots = dotsContainer.children;
						Array.from(dots).forEach((dot, index) => {
							dot.classList.toggle('active', index === actualIndex);
						});
						
						// Handle infinite scroll wraparound
						if (!isTransitioning && withTransition) {
							const clonesAtEnd = Math.min(3, totalCards);
							const totalItemsWithClones = totalCards + clonesAtStart + clonesAtEnd;
							
							setTimeout(() => {
								// If we're at a clone at the end, jump to the beginning
								if (currentIndex >= totalItemsWithClones - clonesAtEnd) {
									isTransitioning = true;
									const offset = currentIndex - (totalItemsWithClones - clonesAtEnd);
									currentIndex = clonesAtStart + offset;
									actualIndex = offset % totalCards;
									updateCarousel(false);
									setTimeout(() => isTransitioning = false, 50);
								}
								// If we're at a clone at the beginning, jump to the end
								else if (currentIndex < clonesAtStart) {
									isTransitioning = true;
									const offset = clonesAtStart - currentIndex;
									currentIndex = totalItemsWithClones - clonesAtEnd - offset;
									actualIndex = (totalCards - offset) % totalCards;
									updateCarousel(false);
									setTimeout(() => isTransitioning = false, 50);
								}
							}, 500);
						}
					}
					
					function goToSlide(index) {
						if (isTransitioning) return;
						
						const { maxIndex } = calculateDimensions();
						actualIndex = Math.max(0, Math.min(index, maxIndex));
						const clonesAtStart = Math.min(3, totalCards);
						currentIndex = clonesAtStart + actualIndex;
						updateCarousel();
						resetAutoPlay(); // Reset timer on manual interaction
					}
					
					function startAutoPlay() {
						stopAutoPlay(); // Clear any existing interval
						autoPlayInterval = setInterval(() => {
							if (!isTransitioning) {
								currentIndex++;
								updateCarousel();
							}
						}, 20000); // 20 seconds
					}
					
					function stopAutoPlay() {
						if (autoPlayInterval) {
							clearInterval(autoPlayInterval);
							autoPlayInterval = null;
						}
					}
					
					function resetAutoPlay() {
						startAutoPlay();
					}
					
					prevBtn.addEventListener('click', () => {
						if (isTransitioning) return;
						
						currentIndex--;
						updateCarousel();
						resetAutoPlay(); // Reset timer on manual interaction
					});
					
					nextBtn.addEventListener('click', () => {
						if (isTransitioning) return;
						
						currentIndex++;
						updateCarousel();
						resetAutoPlay(); // Reset timer on manual interaction
					});
					
					let resizeTimeout;
					window.addEventListener('resize', () => {
						clearTimeout(resizeTimeout);
						resizeTimeout = setTimeout(() => {
							createDots();
							const { maxIndex } = calculateDimensions();
							// Keep actualIndex within bounds
							if (actualIndex > maxIndex) {
								actualIndex = Math.min(actualIndex, maxIndex);
								const clonesAtStart = Math.min(3, totalCards);
								currentIndex = clonesAtStart + actualIndex;
							}
							updateCarousel(false);
						}, 250);
					});
					
					// Initialize infinite scroll
					setupInfiniteScroll();
					createDots();
					updateCarousel(false);
					
					// Start auto-play
					startAutoPlay();
				});
			</script>
		</body>
	</html>
